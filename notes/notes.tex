\documentclass[a4paper,12pt,twoside]{report}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

%------------------------------
% Header settings for all pages
%------------------------------
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\rhead{Kian Nejadfard}
\lhead{Research Kernel}
%------------------------------

%------------------------------
% For timeline
%------------------------------
\newcommand{\foo}{\hspace{-2.3pt}$\bullet$ \hspace{5pt}}
\usepackage{graphicx}
%------------------------------

%------------------------------
% Bibliography configurations
%------------------------------
\usepackage[backend=biber, sorting=none]{biblatex}
\bibliography{notes.bib}
%------------------------------

%------------------------------
% Customizations for lstlisting package
%------------------------------
\usepackage{listings}
\usepackage[utf8]{inputenc}

\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}
%------------------------------

\usepackage{fancyvrb}
%------------------------------

%------------------------------
% Table Configurations
%------------------------------
\usepackage{multirow}
% Spacing between cell content and left/right borders
\setlength{\tabcolsep}{5pt}
% The height of each row is set to 1.5 relative to its default height.
\renewcommand{\arraystretch}{1.3}

% This is to be able to have tables stay within the section they are written at.
\usepackage{float}

\usepackage{longtable}
%------------------------------

\title{Research Kernel}
\author{Kian Nejadfard}

\begin{document}
    \maketitle

    \begin{abstract}
    	RKern is my new research project for developing a kernel from scratch in C++ to evaluate how the use of zero-overhead abstraction mechanisms can affect a kernel project in terms of codebase maintainability, modularity, usability, and performance.
    \end{abstract}

	\chapter{Preface}

	    \section{Motivation}
	    	I have always been interested in how software and hardware work together. Naturally this translated into me being curious about kernels. After all, a kernel is the entity that controls and provides mechanisms for accessing resources by user-space software.

	    	After going through my master's degree coursework, I became more familiar with topics such as the Linux kernel's programming interface along with how parts of the kernel work internally, the assembly language (I mostly used \textit{NASM}), computer and instruction set architecture, how CPUs work internally, basics of compilers and language design.

	    	All of a sudden, I noticed something: the board is set for me to follow two of my lifelong interests. \textit{Developing a kernel from scratch}, and \textit{working with embedded systems}.
	    	It was at this point that I felt more confident about all of this. I could finally understand what's going on at the hardware level, and what it would take for software to "talk" to hardware.

	    \section{Goals}
	        My primary goals for this project and paper are:
	        \begin{itemize}
	            \item \textbf{Learn more about the internals of kernels}.
	            I am a firm believer in learning by doing. Therefore, in my opinion, the best method for learning how kernels work is by making one from scratch. Of course, this is re-inventing a wheel that has been re-invented by many other people so far. However, I see a lot of value in doing this.

	            \item \textbf{Putting a claim to test: Low-overhead abstraction mechanisms in the kernel}.
	            Given that I have always been interested in C++ and have worked with this language a lot since the day that I started programming for the first time. I have been searching for reasons why most kernels are developed in C, and not C++. I have a hypothesis that using C++ and its low-overhead abstraction mechanisms can add many values to kernel development. Times have changed since the 1990s, and C++ has evolved a lot. Along with C++, the tooling has also evolved a lot. When searching for an answer to \textit{"Why basically all kernels in use today are developed with C and not C++?"}, I have come across a lot of rants about how unfit C++ is for such a task, how unreliable the C++ compilers are, and similar negative talks. I am putting such arguments to test in this research.
	            % REFINE THE PREVIOUS PARAGRAPH AND ADD REFERENCES? MAYBE REPHRASE A BIT.
	        \end{itemize}

	    \section*{Timeline}
	        The following is a timeline of key events in this project:
	        \begin{itemize}
	            \item \textbf{August 2018} - The idea started.
	            \item \textbf{September/October 2018} - Built a home office and a PC.
	            \item \textbf{January 2019} - Started research on kernels and operating systems, and created the source repository. I used \textit{osdev.org}\cite{osdev} extensively to learn about the steps it takes to write a basic kernel from scratch.
	            \item \textbf{January 2020} - Finished master's degree courses, no thesis work done yet. The kernel research project has been quiet for a year now as I could not find time to make progress.
	            \item \textbf{February 2020} - Changed jobs,
	            \item \textbf{November 2020} - Started working on the kernel research project again. Chose the name \textit{RKern} for it, and set the project vision.
	        \end{itemize}

    \chapter{Kernels, What They Are, And How They Differ}

	    \section{What Is a Kernel?}
	    	TODO

	    \section{Kernel Types}
	    	TODO

	    \section{A Brief History}
	        TODO: review how Unix, Linux, BSDs, etc. were started. Including a timeline, and also review the timeline of Assembly, C, and C++. The idea is to find out if the main reason for today's kernels' use of C is just the time that they started development and the fact that C was the best and only sane choice at the time. Clearly, after decades of development, you can't just change languages of the kernel. So... maybe it is time for a fresh start!

    \chapter{Prerequisites And Development Setup}

	    \section{Cross-Compiling}
	        Since I am compiling the RKern source code on an x86\_64 machine (host) while targeting different architectures (e.g. x86\_32 or RV) (correct wording?), I need to use a cross-compiler.

	        \subsection{LLVM Toolchain}
	        If using the LLVM toolchain, it is much easier to cross-compile to different targets mainly due to the fact that you don't need to setup anything differently. Just the fact that you have LLVM set up means you can use compilation targets other than your host machine.
	        For example, to use clang++ to compile a C++ source file for i386 architecture, the \verb|--target=i686-pc-none-elf| flag can be used. Similarly, to target the 32-bit RISC-V architecture, \verb|--target=riscv32-unknown-elf| can be used.

			\subsection{GNU Toolchain}
	        This section describes how to build a GNU Toolchain that is capable of compiling source code to RISC-V targets.

            Steps:
            \begin{enumerate}
                \item Clone source repository of riscv-gnu-toolchain located at \lstinline|git@github.com:riscv/riscv-gnu-toolchain.git|. The \lstinline|--recursive| flag should be used since this repository uses submodules. Otherwise, \lstinline|git submodule update --init --recursive| must be executed after cloning.

                \item There are a number of sub-packages needed for compiling this project. The following command is for installing these dependencies on Debian/Ubuntu: \lstinline|apt-get install autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev|

                \item Configure the project with a prefix directory to ensure it is installed into a known, specific directory of your choice (not mixed with directories provided by operating system's packages): \lstinline|./configure --prefix=/home/kian/binaries/gnu-riscv|

                The default architecture is \lstinline|rv64gc|, with "g" standing for MAFD extensions.

                In order to override the default target architecture, use something line \lstinline|./configure --prefix=/home/kian/binaries/gnu-riscv --with-arch=rv32gc --with-abi=ilp32d|.

                The supported architectures are \lstinline|rv32i| or \lstinline|rv64i| plus standard extensions \textit{(a)tomics}, \textit{(m)ultiplication and division}, \textit{(f)loat}, \textit{(d)ouble}, or \textit{(g)eneral} for \textit{MAFD}.

                Supported ABIs are \lstinline|ilp32| (32-bit soft-float), \lstinline|ilp32d| (32-bit hard-float), \lstinline|ilp32f| (32-bit with single-precision in registers and double in memory, niche use only), \lstinline|lp64|, \lstinline|lp64f| \lstinline|lp64d| (same but with 64-bit long and pointers).

                Since we are intending to use this cross-compiler for building the kernel for HiFive1 Rev B, we need to use the target architecture rv32imac with ilp32 ABI.
            \end{enumerate}

    \chapter{Binary File Analysis}

        \section{Disassembling The Binary}

            \begin{verbatim}
llvm-objdump --disassemble-all rkern.bin
objdump -d rkern.bin
            \end{verbatim}

    \chapter{Linkers and Linker Scripts}

        \section{What Do Linkers Do?}
            TODO: use reference http://www.bravegnu.org/gnu-eprog/linker.html

        \section{Linker Script}
            A linker script can define 4 pieces of information:
            \begin{enumerate}
            	\item \textbf{Memory layout}
            	\item \textbf{Section definitions} - Defines the structure of the binary file that will be produced by the linker program.
            	\item \textbf{Options} - Specifications of architecture, entry point, etc. if needed.
            	\item \textbf{Symbols} - Variables that have to be injected into the program at link time.
            \end{enumerate}\cite{memfaultLinkerScripts}

            \subsection{Memory Layout}
                In order to allocate program space, the linker needs to know how much memory is available, and at what addresses that memory exists. This is what the \verb|MEMORY| definition in the linker script is for.

                The syntax for \verb|MEMORY| is as follows:
                \begin{verbatim}
MEMORY
{
    name [(attr)] : ORIGIN = origin, LENGTH = len
    ...
}
                \end{verbatim}
            	Where:
            	\begin{itemize}
            		\item \verb|name| is the region's name. The choice of name is arbitrary as they do not carry any specific meaning. Typical names include \textbf{flash} and \textbf{ram}.
            		\item \verb|(attr)| are optional attributes for the region, such as \verb|w| (writable), \verb|r| (readable), \verb|x| (executable). Flash memory is usually \verb|rx| while ram is usually \verb|wrx|. Notice that these attributes do not actually set memory, rather they just describe the properties of the memory region.
            		\item \verb|origin| is the start address of the memory region.
            		\item \verb|len| is the size of the memory region in bytes.
            	\end{itemize}

            \subsection{Program Headers}
                Also known as \textit{segments}, the \textit{program headers} describe how a program is loaded in memory from an ELF object file format. While the linker creates reasonable program headers by default, sometimes it may be necessary to customize them.\cite{gnuldProgramHeaders}

                In order to observe the program headers of an ELF file, the following command may be used:
\begin{verbatim}
objdump -p <elf file>
\end{verbatim}

                Program headers may be defined by using the \lstinline|PHDRS| command in the linker script:
\begin{verbatim}
PHDRS
{
    name type [ FILEHDR ] [ PHDRS ] [ AT ( address ) ]
[ FLAGS ( flags ) ] ;
}
\end{verbatim}

                Certain program header types describe segments of memory which are loaded from the ELF file by the system loader. In the linker script, the contents of these segments are specified by directing allocated output sections to be placed in the segment. To do this, the command describing the output section in the \lstinline|SECTIONS| command should use \lstinline|:name|, where \lstinline|name| is the program header name as it appears in the \lstinline|PHDRS| command.\cite{gnuldProgramHeaders}

                If a section is placed in one or more segments using `:name', then all subsequent allocated sections which do not specify `:name' are placed in the same segments.\cite{gnuldProgramHeaders}

                The \lstinline|FILEHDR| and \lstinline|PHDRS| keywords which may appear after the program header type also indicate contents of the segment of memory. The \lstinline|FILEHDR| keyword means that the segment should include the ELF file header. The \lstinline|PHDRS| keyword means that the segment should include the ELF program headers themselves.\cite{gnuldProgramHeaders}

                \lstinline|type| may be one of the following\cite{gnuldProgramHeaders}:
                \begin{itemize}
                    \item \lstinline|PT_NULL| - Indicates an unused program header.
                    \item \lstinline|PT_LOAD| - Indicates that this program header describes a segment to be loaded from the file.
                    \item \lstinline|PT_DYNAMIC| - Indicates a segment where dynamic linking information can be found.
                    \item \lstinline|PT_INTERP| - Indicates a segment where the name of the program interpreter may be found.
                    \item \lstinline|PT_NOTE| - Indicates a segment holding note information.
                    \item \lstinline|PT_SHLIB| - A reserved program header type, defined but not specified by the ELF ABI.
                    \item \lstinline|PT_PHDR| - Indicates a segment where the program headers may be found.
                    \item \lstinline|expression| - An expression giving the numeric type of the program header. This may be used for types not defined above.
                \end{itemize}

                It is possible to specify that a segment should be loaded at a particular address in memory. This is done using an \lstinline|AT| expression. This is identical to the \lstinline|AT| command used in the \lstinline|SECTIONS| command. Using the \lstinline|AT| command for a program header overrides any information in the \lstinline|SECTIONS| command.\cite{gnuldProgramHeaders}

                Knowing the above, the following is a simple program header definition for use with HiFive Rev B development board:
\begin{lstlisting}
PHDRS
{
    flash PT_LOAD;
    ram PT_NULL;
}
\end{lstlisting}

            \subsection{Sections}
                The \lstinline|SECTIONS| command controls exactly where input sections are placed into output sections, their order in the output file, and to which output sections they are allocated.\cite{gnuldOutputSections}

                If you do not use a SECTIONS command, the linker places each input section into an identically named output section in the order that the sections are first encountered in the input files. If all input sections are present in the first file, for example, the order of sections in the output file will match the order in the first input file.\cite{gnuldOutputSections}

                In a section definition, you can specify the contents of an output section by listing particular input files, by listing particular input-file sections, or by a combination of the two. You can also place arbitrary data in the section, and define symbols relative to the beginning of the section.\cite{gnuldOutputSections}
\begin{verbatim}
SECTIONS {
    secname : {
        filename( section , section, ... )
    }
}
\end{verbatim}
                The whitespace around \lstinline|secname| is required, so that the section name is unambiguous. The other whitespace shown is optional. You do need the colon \lstinline|:| and the braces \lstinline|{}|, however.\cite{gnuldOutputSections}

                The linker will not create output sections which do not have any contents.\cite{gnuldOutputSections}

                The \lstinline|*( COMMON )| notation can be used to specify where uninitialized data should be placed in the output file.\cite{gnuldOutputSections}

            \subsection{Options}

            \subsection{Symbols}

        \chapter{HiFive1 Rev B}
            After learning about what linkers do and what a linker script is composed of, we should consult the documentation of the hardware that we want to work with, in order to figure out critical information that we need to use for the compilation and linking process.

            \section{Gathering Hardware Information}
            After reviewing the documentations of the \textit{HiFive1 Rev B} board, as well as the \textit{FE310-G002} core that comes with it, I have discovered the following information:
            \begin{itemize}
            	\item The FE310-G002 core is configured to support the RV32IMAC ISA options. This specifies the architecture to be used when producing the binary file.\cite{hifive1RevBConfig}

				\item The data SRAM is 16 KiB.\cite{hifive1RevBConfig}

            	\item The system mask ROM is 8 KiB in size and contains simple boot code.\cite{hifive1RevBConfig}

                \item The mask ROM (MROM) is fixed at design time, and is located on the peripheral bus on FE310-G002, but instructions fetched from MROM are cached by the core’s I-cache. The MROM contains an instruction at address 0x10000 which jumps to the OTP start address at 0x20000.\cite{fe310g002manBootProcess}

                \item A dedicated quad-SPI (QSPI) flash interface is provided to hold code and data for the system. The QSPI interface supports burst reads of 32 bytes over TileLink to accelerate instruction cache refills. The QSPI can be programmed to support eXecute-In-Place modes to reduce SPI command overhead on instruction cache refills. The QSPI interface also supports single-word data reads over the primary TileLink interface, as well as programming operations using memory-mapped control registers.\cite{hifive1RevBConfig}

            	\item FE310-G002 boots by jumping to the beginning of the OTP memory and executing the code found there. As shipped, the OTP memory at the boot location is programmed to jump immediately to the end of the OTP memory, which in turn jumps to the beginning of the SPI Flash at \textbf{0x20000000}.\cite{hifive1RevBBootCode}

                \item The OTP is located on the peripheral bus, with both a control register interface to program the OTP, and a memory read port interface to fetch words from the OTP. Instruction fetches from the OTP memory read port are cached in the E31 core’s instruction cache.\cite{fe310g002manBootProcess}

                \item The HiFive1 Rev B Board is shipped with a modifiable boot loader at the beginning of SPI Flash (0x20000000). At the end of this program’s execution the core jumps to the main user portion of code at \textbf{0x20010000}. This program is designed to allow quick boot, but also a safe reboot option if a “bad” program is flashed into the SPI Flash. A bad program is one which makes it impossible for the programmer to communicate with the board. For example, a program which disables FE310’s active clock, or which puts the core to sleep with no way of waking it up. Bad programs can always be restarted using the RESET button, and using the “safe” bootloader can be halted before they perform any unsafe behavior.\cite{hifive1RevBBootLoader}

            	\item To activate normal boot mode, press the RESET button on the HiFive1 Rev B. After approximately 1 second, the green LED will flash for 1/2 second, then the user program will execute.\cite{hifive1RevBBootLoader}

                \item To activate safe boot mode, press the RESET button. When the green LED flashes, immediately press the RESET button again. After 1 second, the red LED will blink. The user program will not execute, and the programmer can connect. To exit “safe” boot mode, press the RESET button a final time.\cite{hifive1RevBBootLoader}

                \item There are 3 serial peripheral interface (SPI) controllers. Each controller provides a means for serial communication between the FE310-G002 and off-chip devices, like quad-SPI Flash memory. Each controller supports master-only operation over single-lane, dual-lane, and quad-lane protocols. Each controller supports burst reads of 32 bytes over TileLink to accelerate instruction cache refills. 1 SPI controller can be programmed to support eXecute-In-Place (XIP) modes to reduce SPI command overhead on instruction cache refills.\cite{fe310g002manOverview}

                \item Two universal asynchronous receiver/transmitter (UARTs) are available and provide a means for serial communication between the FE310-G002 and off-chip devices.\cite{fe310g002manOverview}

                \item The FE310-G002 has an I2C controller to communicate with external I2C devices, such as sensors, ADCs, etc.\cite{fe310g002manOverview}

                \item The FE310-G002 provides external debugger support over an industry-standard JTAG port, including 8 hardware-programmable breakpoints per hart.\cite{fe310g002manOverview}
            \end{itemize}

            \section{Memory Map}
            	The following tables show the FE310-G002 memory map along with relevant attributes:\cite{fe310g002manMMap}

            	\begin{table}[H]
            		\centering
            		\begin{tabular}{| p{3cm} | c | c | p{3cm} |}
            			\hline
            			\textbf{Description} & \textbf{Base} & \textbf{Top} & \textbf{Attributes}\\
            			\hline
            			\hline
            			Debug & 0x0000\_0000 & 0x0000\_0FFF & RWX A\\
            			\hline
            		\end{tabular}
            		\caption{Debug Address Space}
            	\end{table}

            	\begin{table}[H]
            		\centering
            		\begin{tabular}{| p{4cm} | c | c | p{3cm} |}
            			\hline
            			\textbf{Description} & \textbf{Base} & \textbf{Top} & \textbf{Attributes}\\
            			\hline
            			Mode Select & 0x0000\_1000 & 0x0000\_1FFF & R XC\\
            			Reserved & 0x0000\_2000 & 0x0000\_2FFF & \\
            			Error Device & 0x0000\_3000 & 0x0000\_3FFF & RWX A\\
            			Reserved & 0x0000\_4000 & 0x0000\_FFFF & \\
            			Mask ROM & 0x0001\_0000 & 0x0001\_1FFF & R XC\\
            			Reserved & 0x0001\_2000 & 0x0001\_FFFF & \\
            			OTP Memory Region & 0x0002\_0000 & 0x0002\_1FFF & R XC\\
            			Reserved & 0x0002\_2000 & 0x001F\_FFFF & \\
            			\hline
            		\end{tabular}
            		\caption{On-Chip Non Volatile Memory}
            	\end{table}

                \begin{longtable}[H]{| p{4.5cm} | p{3cm} | p{3cm} | p{2.5cm} |}
               		\hline
               		\textbf{Description} & \textbf{Base} & \textbf{Top} & \textbf{Attributes}\\
               		\hline
               		\hline
               		\endfirsthead
                    CLINT & 0x0200\_0000 & 0x0200\_FFFF & RW A\\
                    Reserved & 0x0201\_0000 & 0x07FF\_FFFF & \\
                    E31 ITIM (8 KiB) & 0x0800\_0000 & 0x0800\_1FFF & RWX A\\
                    Reserved & 0x0800\_2000 & 0x0BFF\_FFFF & \\
                    PLIC & 0x0C00\_0000 & 0x0FFF\_FFFF & RW A\\
                    AON & 0x1000\_0000 & 0x1000\_0FFF & RW A\\
               		Reserved & 0x1000\_1000 & 0x1000\_7FFF & \\
               		PRCI & 0x1000\_8000 & 0x1000\_8FFF & RW A\\
               		Reserved & 0x1000\_9000 & 0x1000\_FFFF & \\
               		OTP Control & 0x1001\_0000 & 0x1001\_0FFF & RW A\\
               		Reserved & 0x1001\_1000 & 0x1001\_1FFF & \\
               		GPIO & 0x1001\_2000 & 0x1001\_2FFF & RW A\\
               		UART 0 & 0x1001\_3000 & 0x1001\_3FFF & RW A\\
               		QSPI 0 & 0x1001\_4000 & 0x1001\_4FFF & RW A\\
               		PWM 0 & 0x1001\_5000 & 0x1001\_5FFF & RW A\\
               		I2C 0 & 0x1001\_6000 & 0x1001\_6FFF & RW A\\
               		Reserved & 0x1001\_7000 & 0x1002\_2FFF & \\
               		UART 1 & 0x1002\_3000 & 0x1002\_3FFF & RW A\\
               		SPI 1 & 0x1002\_4000 & 0x1002\_4FFF & RW A\\
               		PWM 1 & 0x1002\_5000 & 0x1002\_5FFF & RW A\\
               		Reserved & 0x1002\_6000 & 0x1003\_3FFF & \\
               		SPI 2 & 0x1003\_4000 & 0x1003\_4FFF & RW A\\
               		PWM 2 & 0x1003\_5000 & 0x1003\_5FFF & RW A\\
               		Reserved & 0x1003\_6000 & 0x1FFF\_FFFF & \\
               		\hline
               		\caption{On-Chip Peripherals}
                \end{longtable}

            	\begin{table}[H]
            		\centering
            		\begin{tabular}{| p{4.5cm} | p{3cm} | p{3cm} | p{2.5cm} |}
            			\hline
            			\textbf{Description} & \textbf{Base} & \textbf{Top} & \textbf{Attributes}\\
            			\hline
            			\hline
            			QSPI 0 Flash (512 MiB) & 0x2000\_0000 & 0x3FFF\_FFFF & R XC\\
            			Reserved & 0x4000\_0000 & 0x7FFF\_FFFF & \\
            			\hline
            		\end{tabular}
            		\caption{Off-Chip Non-volatile Memory}
            	\end{table}

            	\begin{table}[H]
            		\centering
            		\begin{tabular}{| p{4.5cm} | p{3cm} | p{3cm} | p{2.5cm} |}
            			\hline
            			\textbf{Description} & \textbf{Base} & \textbf{Top} & \textbf{Attributes}\\
            			\hline
            			\hline
            			E31 DTIM (16 KiB) & 0x8000\_0000 & 0x8000\_3FFF & RWX A\\
            			Reserved & 0x8000\_4000 & 0xFFFF\_FFFF & \\
            			\hline
            		\end{tabular}
            		\caption{On-Chip Volatile Memory}
            	\end{table}
        \chapter{Communication Protocols}
            This chapter describes the most basic communication protocols used in today's embedded devices.

            \section{Inter-Integrated Circuit (I2C)}
                The contents of this section are based on the I2C-bus specification revision 6 published by NXP Semiconductor\cite{i2cBusSpec}.

                The I2C protocol allows multiple primary devices to communicate with multiple secondary devices, using only two wires: \textit{serial data} (\textit{SDL}) and \textit{serial clock} (\textit{SCL}).

                Each device on the I2C bus is identified by a unique address and can operate either as a \textit{transmitter} or a \textit{receiver}. It makes sense for certain devices, for example, LCDs, to always be receivers.

                In addition to being a transmitter an/or receiver, each device on the bus may be considered a primary or a secondary. If you are familiar with computer networking, you can think of the primary device as the client: this is the device that initiates the data transfer by generating the clock signals. The secondary device can be thought of as the server: this is the device that receives signals from the primary device. (TODO: rephrase or reword? Better explanation?)

                There may be multiple primary devices connected to the I2C bus, which means at a given time, multiple primary devices may try to take control of the bus. In times like this, the \textit{arbitration} procedure ensures that only one primary device is allowed to take control of the bus and transmit data properly (the winning message).

                \subsection{SDA and SCL}
                    Both SDA and SCL are set to HIGH (they have current) by default. Data may be transferred at rates of up to 100 kbps (standard mode), 400 kbps (fast mode), 1 mbps (fast mode plus), and 3.4 mbps (high-speed mode).

                    Due to the variety of different device technologies that I2C supports, the levels for LOW (0) and HIGH (1) are not fixed. Rather, they depend on the associated level of $V_{DD}$. Input reference levels are set as follows:
                    \begin{itemize}
                        \item $V_{IL} = 0.3 V_{DD}$
                        \item $V_{IH} = 0.7 V_{DD}$
                    \end{itemize}

                    There are some legacy devices with fixed input levels at $V_{IL} = 1.5V$ and $V_{IH} = 3.0V$. However, most new devices use the $V_{DD}$-associated input levels.

                    For the transfer of each data bit, one clock pulse must be generated. When the clock line has a HIGH value, the data line must remain stable to be considered valid. When the data line's level is intended to change, the clock line must be LOW.

                    // TODO: need diagram for the above. There is one in NXP doc but perhaps I should draw one myself.

                \subsection{Start and Stop Conditions}
                    All transactions are initiated with the start condition, and terminated with the stop condition. The start and stop conditions are defined as:
                    \begin{itemize}
                        \item \textbf{Start} - SDA line transitions from HIGH to LOW while SCL is HIGH.
                        \item \textbf{Stop} - SDA line transitions from LOW to HIGH while SCL is HIGH.
                    \end{itemize}

                    // TODO: needs diagram

                    Start and stop conditions are always generated by the primary device. After the start condition is transmitted, the bus is considered \textit{busy}. At a certain time after the stop condition, the bus is considered \textit{free} again.

                    Micro-controllers must sample the SDA line twice per clock period to sense the transition.

                \subsection{Byte Format}
                    Every byte that is transmitted on the SDA line must be 8 bits long, which means, there cannot be a data transfer of, say, 4 bits. This would still be 8 bits of data transfer where the last 4 bits would get ignored. (TODO: correct?)

                    Each byte is concluded with an ACK bit.

                    Data is transferred with the most significant bit first.

                    If a secondary device cannot receive or transmit another complete byte of data until it has done something else that it has to do, it can hold the SCL line as LOW to force the primary device in a waiting state. When the secondary device is ready again for receiving or transmitting, it releases the SCL line so it goes HIGH again.

                    // TODO CRITICAL: A nice diagram showing a byte transfer, a wait state, then another byte, then stop condition.

                \subsection{ACK and NACK}
                    \textit{Acknowledge bit} must follow every byte of data. This bit allows the receiver to signal the transmitter that the byte was successfully received, and another byte may be transmitted. The primary device generates all clock signals, including the clock signal for the acknowledge bit.

                    The ACK bit is defined as:
                    \begin{itemize}
                        \item Transmitter releases the SDA line during the ACK clock signal.
                        \item Receiver can now pull the SDA line to LOW.
                        \item The SDA line remains LOW during the HIGH period of the clock signal.
                    \end{itemize}

                    The setup and hold times must be taken into account. (TODO: there is a chart for this in section 6 of the spec document)

                    If the SDA line remains HIGH during the ACK clock signal, it is considered a \textit{Not Acknowledge} bit, or NACK. In such case, the primary device can either generate or stop condition to abort the data transfer, or repeat the start condition to initiate a new data transfer. There are five conditions that can result in a NACK:
                    \begin{itemize}
                        \item No receiver is present on the bus with the transmitted address, therefore there is no device to respond to the data transfer.
                        \item The receiver device is momentarily unable to receive or transmit data because it is reacting to a real-time function and is currently not ready to communicate with the primary device.
                        \item The receiver has received data or commands that it is unable to understand.
                        \item The receiver is unable to receive any more data.
                        \item A primary-receiver device must signal the end of the transfer (stop condition) to the secondary-transmitter device.
                    \end{itemize}

                \subsection{Arbitration Procedure}
                    TODO

            \section{Serial Peripheral Interface (SPI)}
                TODO
    \printbibliography
\end{document}
